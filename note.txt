[56. Implement background worker with Redis task queue]

ก่อนหน้านี้เรา implement แต่ synchronous APIs นั้นคือ เมื่อ client ส่ง request ให้ server นั้น request ก็จะถูก processed ทันทีโดย server แล้วก็ return result ไปที่ client ทันที ซึ่งเหมาะกับ use case ส่วนใหญ่
แต่ใน real-world project นั้นบางครั้งมันไม่สามารถ process request ทันทีได้ บางครั้งอาจเพราะมันต้องใช้เวลานานหว่าจะ complete ซึ่งนั้นอาจ force client ให้รอ ซึ่งเราอาจไม่ต้องการเกิด client รอ

เราเลยต้องการ mechanism ที่จะ process task แบบ asynchronously
    1 ซึ่ง solution นึงคือใช้ Go routines เพื่อ process task ใน background ซึ่งถือว่าง่ายต่อการ implement แต่ข้อเสียของวิธีนี้คือ tasks มันอยู่ใน process's memory ดังนั้นถ้า server down ขึ้นมา unprocessed tasks ต่างๆจะหายไป
    2 อีกวิธีนึงนั้นก็คือส่ง tasks ไปที่ queue ของ message broker นั้นเอง ซึ่ง broker ที่นิยมอันนึงก็คือ Redis โดยมันจะ store data ลงทั้ง memory และ persistent storage
        และเมื่อ running production ด้วย Redis sentinel หรือ Redis cluster มันก็จะทำให้เรามั้นใจได้ว่า message broker ของเรามีความพร้อมใช้งานสูง และ tasks ที่ส่งเข้า queue จะไม่มีทางหายไป
        เราจะใช้ในการ "send verification email" use case ใน course นี้

        โดยเราจะใช้ package ชื่อ asynq -> https://github.com/hibiken/asynq ซึ่งมันทั้ง simple, reliable, efficient ในการ distributed task queue library ซึ่งทำให้เรา enqueue และ process tasks asynchronously โดยใช้ background workers


[57. Integrate async worker to Go web server]

1 อย่างแรกเลยคือต้องเอา Redis มารันใน docker ก่อน (https://hub.docker.com/_/redis) 
    `docker exec -it redis redis-cli ping` -> เพื่อตรวจสอบการรันใน docker

[58. Send async tasks to Redis within a DB transaction]

[59. How to handle errors and print logs for Async workers]

เนื่องจากว่าถ้า task process แล้วเกิด error มันจะยังไม่แสดง error ออกมาที่ console เลยต้องมาจัดการใน lecture นี้ 

คุณจำลอง error โดยการยิง v1/create_user จากนั้นก็กดหยุดรัน postgres db ซึ่งเนื่องจากกำหนด delay ในการเอา task จาก redis มารัน 10s เมื่อครบ 10s มันก็จะแจ้ง error เพราะว่ามัน get user ไม่ได้ เลย error ที่ `GetUser(ctx, payload.Username)` ใน ProcessTaskSendVerifyEmail

Error ที่ขึ้นคือ
`
2:38PM ERR process task failed error="failed to get user: read tcp [::1]:56941->[::1]:5432: read: connection reset by peer" payload="{\"username\":\"mick19\"}" type=task:send_verify_email
`
(เนื่องจากคุณกด stop ใน docker desktop ถ้ากด Pause นั้น error นี้จะไม่ขึ้นนะ แต่ถ้ากด stop นัั้นแหละ error ถึงจะขึ้น)

แต่เมื่อคุณกดรัน postgres db อีกครั้ง task processor ก็จะรัน task จนสำเร็จทันทีเลย

[60. Some delay might be good for your async tasks]

ลองปรับ code ให้ไม่ทำการ delay เพื่อ process task เพื่อดูว่า การ delay task นั้นมันสำคัญแค่ใหน

เนื่องจาก transactions ในงานจริงนั้นมันไม่ได้ commit ในเวลาอันรวดเร็วเสมอไป เพราะบางครั้งมันก็ช้า ตามจำนวน traffic ที่เข้ามาใน system เรา เป็นต้น