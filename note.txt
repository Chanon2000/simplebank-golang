[56. Implement background worker with Redis task queue]

ก่อนหน้านี้เรา implement แต่ synchronous APIs นั้นคือ เมื่อ client ส่ง request ให้ server นั้น request ก็จะถูก processed ทันทีโดย server แล้วก็ return result ไปที่ client ทันที ซึ่งเหมาะกับ use case ส่วนใหญ่
แต่ใน real-world project นั้นบางครั้งมันไม่สามารถ process request ทันทีได้ บางครั้งอาจเพราะมันต้องใช้เวลานานหว่าจะ complete ซึ่งนั้นอาจ force client ให้รอ ซึ่งเราอาจไม่ต้องการเกิด client รอ

เราเลยต้องการ mechanism ที่จะ process task แบบ asynchronously
    1 ซึ่ง solution นึงคือใช้ Go routines เพื่อ process task ใน background ซึ่งถือว่าง่ายต่อการ implement แต่ข้อเสียของวิธีนี้คือ tasks มันอยู่ใน process's memory ดังนั้นถ้า server down ขึ้นมา unprocessed tasks ต่างๆจะหายไป
    2 อีกวิธีนึงนั้นก็คือส่ง tasks ไปที่ queue ของ message broker นั้นเอง ซึ่ง broker ที่นิยมอันนึงก็คือ Redis โดยมันจะ store data ลงทั้ง memory และ persistent storage
        และเมื่อ running production ด้วย Redis sentinel หรือ Redis cluster มันก็จะทำให้เรามั้นใจได้ว่า message broker ของเรามีความพร้อมใช้งานสูง และ tasks ที่ส่งเข้า queue จะไม่มีทางหายไป
        เราจะใช้ในการ "send verification email" use case ใน course นี้

        โดยเราจะใช้ package ชื่อ asynq -> https://github.com/hibiken/asynq ซึ่งมันทั้ง simple, reliable, efficient ในการ distributed task queue library ซึ่งทำให้เรา enqueue และ process tasks asynchronously โดยใช้ background workers


[57. Integrate async worker to Go web server]

1 อย่างแรกเลยคือต้องเอา Redis มารันใน docker ก่อน (https://hub.docker.com/_/redis) 
    `docker exec -it redis redis-cli ping` -> เพื่อตรวจสอบการรันใน docker

[58. Send async tasks to Redis within a DB transaction]

[59. How to handle errors and print logs for Async workers]

เนื่องจากว่าถ้า task process แล้วเกิด error มันจะยังไม่แสดง error ออกมาที่ console เลยต้องมาจัดการใน lecture นี้ 

คุณจำลอง error โดยการยิง v1/create_user จากนั้นก็กดหยุดรัน postgres db ซึ่งเนื่องจากกำหนด delay ในการเอา task จาก redis มารัน 10s เมื่อครบ 10s มันก็จะแจ้ง error เพราะว่ามัน get user ไม่ได้ เลย error ที่ `GetUser(ctx, payload.Username)` ใน ProcessTaskSendVerifyEmail

Error ที่ขึ้นคือ
`
2:38PM ERR process task failed error="failed to get user: read tcp [::1]:56941->[::1]:5432: read: connection reset by peer" payload="{\"username\":\"mick19\"}" type=task:send_verify_email
`
(เนื่องจากคุณกด stop ใน docker desktop ถ้ากด Pause นั้น error นี้จะไม่ขึ้นนะ แต่ถ้ากด stop นัั้นแหละ error ถึงจะขึ้น)

แต่เมื่อคุณกดรัน postgres db อีกครั้ง task processor ก็จะรัน task จนสำเร็จทันทีเลย

[60. Some delay might be good for your async tasks]

ลองปรับ code ให้ไม่ทำการ delay เพื่อ process task เพื่อดูว่า การ delay task นั้นมันสำคัญแค่ใหน

เนื่องจาก transactions ในงานจริงนั้นมันไม่ได้ commit ในเวลาอันรวดเร็วเสมอไป เพราะบางครั้งมันก็ช้า ตามจำนวน traffic ที่เข้ามาใน system เรา เป็นต้น

[61. How to send email in Go via Gmail]

เราจะส่ง email โดยใช้ smtp -> https://pkg.go.dev/net/smtp แต่เพื่อความรวดเร็ว 
    เราสามารถใช้ comunity package นั้นคือ gomail -> https://github.com/go-gomail/gomail ที่ implement การส่ง email โดยใช้ smtp ในระดับนึงแล้วให้เรา แต่ repo มันค่อนข้างเก่า นั้นคือประมาณ 8ปีแล้ว และไม่มีการ maintain ใดๆ
    เลยมีอีก package คือ https://github.com/jordan-wright/email ซึ่งดูใหม่กว่า (ดังนั้นเราจะใช้ package นี้เพื่อความรวดเร็ว)


# เพิ่มเติม: ตอนสร้าง app password ที่ gmail นั้นคุณใช้เวลานานมาก เพราะหาุดสร้าง app password ไม่ได้ สุดท้าย search เอาที่ topbar ของ gmail management ถึงจะเจอ !!!

แต่แน่นอนว่ามีวิธีอื่นในการส่ง mail โดยใช้พวก third-party service เช่น AWS SES (ถ้าคุณใช้ cloud เป็น AWS) ซึ่งก็จะใช้ผ่าน AWS golang SDK เป็นต้น


[62. How to skip test in Go and config test flag in vscode]

เนื่องจากเราใส่ sender_test ใน lecture ที่แล้ว นั้นทำให้ถ้าเรารัน workflow ใน github นั้นอาจทำให้ มันจะส่ง mail ทุกครั้งที่รัน workflow ดังนั้นเราควรจะ skip sender_test test ใน workflow

สามารถ setting go test ใน vscode ได้โดย ไปที่ setting แล้ว search ด้วย `go test flag` -> ที่ "go.testFlags" ใน settings.json


[63. Email verification feature: design DB and send email]


# เนื่องจากเรา deploy db ของ production และมี data เก็บอยู่แล้ว เราเลยไม่อาจ drop db แล้วสร้างใหม่ได้ เลยใช้วิธีสร้าง migration script ใหม่นั้นเอง ในครั้งนี้นั้นคือ 